# EORA Q&A Assistant

Этот проект представляет собой RAG (Retrieval-Augmented Generation) систему, предназначенную для ответов на вопросы на основе кейсов компании EORA. Ассистент парсит веб-страницы с кейсами, индексирует их содержимое и использует LLM для генерации ответов.

---

## Что использовал

* **Google Generative AI**:
    * Модель для эмбеддингов: `embedding-001`
    * Модель для генерации ответов: `gemma-3n-e4b-it`
* **ChromaDB**: Локальная векторная база данных для хранения эмбеддингов.
* **Beautiful Soup 4 (bs4)**: Для парсинга HTML-страниц с кейсами.
* **Poetry**: Для управления зависимостями.

---

Как работает:

1.  **Сбор данных**: Скрипт получает список URL-адресов страниц с кейсами. С помощью **Beautiful Soup** извлекается основное текстовое содержимое каждой страницы.

2.  **Разбиение на чанки**: Полученный текст разбивается на небольшие фрагменты (чанки) для более точного поиска.

3.  **Векторизация и хранение**: Каждый чанк текста преобразуется в числовой вектор (эмбеддинг) с помощью модели `embedding-001` от Google. Эти векторы вместе с исходным текстом и метаданными сохраняются в локальной векторной базе **ChromaDB**.

4.  **Поиск и генерация**:
    * Когда пользователь задает вопрос, он также преобразуется в вектор с помощью той же модели эмбеддингов.
    * Система выполняет поиск семантически близких векторов в **ChromaDB**, находя наиболее релевантные чанки текста.
    * Эти чанки (контекст) вместе с оригинальным вопросом пользователя отправляются в генеративную модель **gemma-3n-e4b-it**, которая формирует финальный, осмысленный ответ.

---

## Установка

1.  **Клонируйте репозиторий:**
    ```bash
    git clone https://github.com/Beatum11/eora_t
    cd eora_t
    ```

2.  **Создайте и активируйте виртуальное окружение:**
    * Poetry сделает это автоматически.

3.  **Установите зависимости:**
    ```bash
    poetry install
    ```

4.  **Настройте переменные окружения:**
    * Создайте файл `.env` в корне проекта.
    * Добавьте в него ваш API-ключ от Google:
        ```
        GOOGLE_API_KEY="your_secret_api_key_here"
        ```

---

## Что нужно улучшить

Если бы было больше времени, я бы сосредоточился на следующих улучшениях для повышения надежности и производительности системы:

* Добавить тесты: Написать юнит-тесты для утилит (например, для функции разбиения на чанки) и интеграционные тесты для всего пайплайна с использованием `pytest`.

* Использовать `pydantic-settings`: Для более строгой и удобной валидации переменных окружения (API-ключи, пути к БД).

* Улучшить обработку ошибок: Внедрить более продуманную обработку потенциальных ошибок (сетевые сбои, ошибки API) и добавить механизмы повторных запросов (**retry mechanisms**) с использованием библиотек, таких как `tenacity`.

* Добавить кэширование: Реализовать слой кэширования (например, с помощью `functools.lru_cache` для простых случаев или Redis для более сложных) для эмбеддингов часто запрашиваемых текстов, чтобы сократить количество обращений к API и ускорить ответы.
